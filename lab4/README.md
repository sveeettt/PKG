# Raster Algorithms Web Application

Веб-приложение для визуализации базовых растровых алгоритмов с использованием Docker-контейнеризации.

##  О проекте

Интерактивное веб-приложение для изучения и сравнения различных алгоритмов растровой графики. Приложение предоставляет визуализацию в реальном времени с возможностью интерактивного управления параметрами.

**Основные функции:**
- Визуализация 5 различных алгоритмов растровой графики
- Интерактивная координатная система с масштабированием
- Измерение времени выполнения алгоритмов
- Адаптивный пользовательский интерфейс

##  Алгоритмы реализации

### 1. **Пошаговый алгоритм** (`stepByStep` в script.js)
```javascript
function stepByStep(x1, y1, x2, y2) {
    // Определение основного направления (X или Y)
    // Постепенное вычисление координат с округлением
    // Построение линии пошагово с визуализацией
}
```
**Принцип работы:** Алгоритм определяет, по какой оси происходит большее изменение, и использует ее как основную для итераций.

### 2. **Алгоритм ЦДА** (Цифровой Дифференциальный Анализатор)
```javascript
function DDA(x1, y1, x2, y2) {
    // Вычисление количества шагов
    // Равномерное приращение координат
    // Округление до ближайшего пикселя
}
```
**Особенности:** Использует вещественную арифметику, обеспечивает плавное построение.

### 3. **Алгоритм Брезенхема для линии**
```javascript
function bresenham(x0, y0, x1, y1) {
    // Целочисленные вычисления
    // Управление ошибкой для выбора пикселей
    // Оптимизация без умножения и деления
}
```
**Преимущества:** Высокая скорость за счет целочисленных операций.

### 4. **Алгоритм Кастла-Питвея**
```javascript
function castlePitteway(x1, y1, x2, y2) {
    // Улучшенная версия Брезенхема
    // Симметричное построение
    // Эффективное управление ошибкой
}
```

### 5. **Алгоритм Брезенхема для окружности**
```javascript
function bresenhamCircle(xc, yc, r) {
    // Построение по октантам
    // Использование симметрии
    // Целочисленные вычисления
}
```

##  Архитектура проекта

### **Frontend-структура:**

#### `index.html` - Основная структура
```html
<!-- Координатная система ввода -->
<div class="input-group">
    <label>X1: <input type="number" id="x1" value="10"></label>
    <label>Y1: <input type="number" id="y1" value="10"></label>
    <!-- ... -->
</div>

<!-- Canvas для визуализации -->
<canvas id="canvas" width="800" height="600"></canvas>
```

#### `style.css` - Визуальное оформление
- **Адаптивный дизайн** с медиа-запросами
- **CSS Grid/Flexbox** для layout
- **Плавные анимации** и переходы
- **Кастомные элементы** управления

#### `script.js` - Основная логика алгоритмов

**Ключевые функции:**

1. **Управление координатной системой:**
```javascript
function drawGrid() {
    // Отрисовка сетки с учетом масштаба
    // Отображение координатных осей
    // Подписи значений по осям
}
```

2. **Система трансформаций:**
```javascript
let scale = 20.0; // Текущий масштаб
let offsetX = 0;  // Смещение по X
let offsetY = 0;  // Смещение по Y

function plotPixel(x, y, color = 'green', connect = true) {
    // Преобразование математических координат в экранные
    const pixelX = centerX + x * scale;
    const pixelY = centerY - y * scale; // Инверсия Y для математической системы
}
```

3. **Обработка пользовательского ввода:**
```javascript
// Перетаскивание холста
canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
});

// Масштабирование колесом мыши
canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomIntensity = 0.05;
    // Вычисление нового масштаба с ограничениями
});
```

#### `ui.js` - Управление интерфейсом
```javascript
function drawSelectedAlgorithm() {
    // Определение выбранного алгоритма
    // Вызов соответствующей функции отрисовки
    // Обновление информации о времени выполнения
}

function clearCanvas() {
    // Сброс состояния
    // Очистка холста
    // Обновление интерфейса
}
```

### **Backend-инфраструктура:**

#### `Dockerfile` - Контейнеризация
```dockerfile
FROM nginx:alpine
COPY src/ /usr/share/nginx/html/
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### `nginx.conf` - Веб-сервер
```nginx
server {
    listen 80;
    root /usr/share/nginx/html;
    
    # Кэширование статических ресурсов
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

##  Технические детали реализации

### **Система координат:**
- **Математическая система**: центр (0,0) в центре холста, Y направлен вверх
- **Экранная система**: левый верхний угол (0,0), Y направлен вниз
- **Преобразование**: `экранный_Y = центр_Y - математический_Y * масштаб`

### **Механизм масштабирования:**
```javascript
function updateScale() {
    scale = parseFloat(document.getElementById('scale').value);
    scale = Math.min(Math.max(5, scale), 50); // Ограничение 5-50
    redraw(); // Перерисовка с новым масштабом
}
```

### **Визуализация алгоритмов:**
Каждый алгоритм реализует:
1. **Сброс состояния** предыдущей отрисовки
2. **Вычисление координат** пикселей
3. **Постепенную отрисовку** с соединением точек
4. **Измерение времени** выполнения

### **Оптимизации:**
- **Кэширование** последней отрисованной функции для перерисовки при масштабировании
- **Эффективное обновление** только изменяющихся элементов


##  Руководство пользователя

### **Базовое использование:**
1. Выберите алгоритм из выпадающего списка
2. Введите координаты точек или радиус
3. Нажмите "Запуск" для визуализации
4. Используйте "Очистить" для сброса

### **Расширенные возможности:**
- **Перетаскивание**: зажмите левую кнопку мыши на холсте для перемещения
- **Масштабирование**: используйте колесо мыши или ползунок масштаба
- **Анализ производительности**: смотрите время выполнения в миллисекундах

### **Особенности алгоритмов:**
- **Для линейных алгоритмов**: используйте координаты X1,Y1 и X2,Y2
- **Для окружности**: используйте радиус (координаты центра фиксированы в 0,0)

##  Развертывание

### **Локальная разработка:**
```bash
# Клонирование репозитория
git clone https://github.com/sveeettt/raster-algorithms.git
cd raster-algorithms

# Запуск через локальный сервер
python -m http.server 8000
# или
npx http-server src
```

### **Docker-развертывание:**
```bash
# Сборка образа
docker build -t raster-algorithms .

# Запуск контейнера
docker run -d -p 8080:80 --name raster-app raster-algorithms

# Проверка работы
open http://localhost:8080
```

### **Продакшн-развертывание:**
```bash
# Использование образа из Docker Hub
docker run -d -p 80:80 --restart unless-stopped svveeettt/raster_algorithms:latest
```


##  Производительность и оптимизации

### **Измерение времени:**
```javascript
const start = performance.now();
// Выполнение алгоритма
const time = performance.now() - start;
```

### **Структура функции алгоритма:**
```javascript
function newAlgorithm(x1, y1, x2, y2) {
    const start = performance.now();
    resetPlotPixel();
    
    // Реализация алгоритма
    // Использование plotPixel() для отрисовки
    
    return performance.now() - start;
}
```

##  Известные ограничения

- Максимальный масштаб ограничен 50x
- Большие значения координат могут вызвать переполнение
- Некоторые алгоритмы могут работать медленно при больших радиусах

